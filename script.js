document.addEventListener('DOMContentLoaded', () => {
    // --- 1. State Variables ---
    let numberOfPlayers = 0;
    let currentPlayerSetupIndex = 0;
    let playerData = [];
    let selectedClasses = [];
    let currentGameState = {};
    let gameHistory = []; // For Undo

    // --- 2. Constants ---
    const AP_COST = {
        MOVE: 1, PIVOT: 1, SHOOT: 3, SILVER_BULLET: 3,
        THROW_HAZARD: 1, THROW_DYNAMITE: 2,
        // Add other action costs later
    };
    const DIRECTIONS = ['N', 'E', 'S', 'W'];
    const CLASS_DATA = { // Includes Narrative Descriptions & Colors
        "Sheriff": {
            color: "color-sheriff", description: "A faction of Vampires enforcing order...", abilities: [
                { name: "Under My Protection (Passive)", description: "The Sheriff shields nearby Bloodwells..." },
                { name: "Swift Justice (Passive)", description: "Justice waits for no dawn..." },
                { name: "Order Restored (Active, 1/game)", description: "(3 AP) Even death cannot stop..." }
            ] },
        "Vigilante": {
            color: "color-vigilante", description: "A faction of Vampires seeking justice...", abilities: [
                { name: "Side by Side (Passive)", description: "These Blood Brothers act as one..." },
                { name: "Blood Brothers (Passive)", description: "When fighting close together..." },
                { name: "Vengeance is Mine (Active, 1/game)", description: "(0 AP) Harm my kin, feel my wrath!..." }
            ] },
        "Outlaw": {
            color: "color-outlaw", description: "A faction of Vampires thriving on chaos...", abilities: [
                { name: "Daring Escape (Passive)", description: "Shoot, grin, and vanish!..." },
                { name: "Hand Cannon (Active, 1/game)", description: "(5 AP) Unleash hellfire..." },
                { name: "Rampage (Active, 1/game)", description: "(2 AP) A whirlwind of lead..." }
            ] },
        "Bounty Hunter": {
            color: "color-bounty-hunter", description: "A faction of Vampires hunting for profit...", abilities: [
                { name: "Sharpshooter (Passive)", description: "No cover is safe..." },
                { name: "Marked Man (Passive)", description: "Every bullet carries a hex..." },
                { name: "Contract Payoff (Active, 1/game)", description: "(3 AP) Collecting the blood-price..." }
            ] }
    };
    const LAYOUT_DATA = { // Example Layouts
        '2': [ { /* Layout 2P-1 Data */ vampires: [...], bloodwells: [...], hazards: [...] } ],
        '3': [ { /* Layout 3P-1 Data */ vampires: [...], bloodwells: [...], hazards: [...] } ],
        '4': [ { /* Layout 4P-1 Data */ vampires: [...], bloodwells: [...], hazards: [...] }, { /* Layout R1 Data */ vampires: [...], bloodwells: [...], hazards: [...] } ]
    }; // NOTE: Layout data abbreviated in comment block, full data included below

    // --- 3. DOM Element References ---
    const screens = {
        playerCount: document.getElementById('screen-player-count'),
        playerSetup: document.getElementById('screen-player-setup'),
        gameplay: document.getElementById('screen-gameplay'),
    };
    const popups = {
       elimination: document.getElementById('popup-elimination'),
       victory: document.getElementById('popup-victory'),
    }
    const playerCountButtons = screens.playerCount.querySelectorAll('button[data-count]');
    const playerSetupTitle = document.getElementById('player-setup-title');
    const playerNameLabel = document.getElementById('player-name-label');
    const playerNameInput = document.getElementById('input-player-name');
    const classSelectionContainer = document.getElementById('class-selection-buttons');
    const classButtons = classSelectionContainer.querySelectorAll('.btn-class');
    const classDetailsName = document.getElementById('class-name'); // Setup details
    const classDetailsDescription = document.getElementById('class-description'); // Setup details
    const classDetailsAbilities = document.getElementById('class-abilities'); // Setup details
    const classDetailsContainer = document.getElementById('class-details-container');
    const btnBack = document.getElementById('btn-back');
    const btnNext = document.getElementById('btn-next');
    const gameplayScreen = screens.gameplay;
    const actionBar = document.getElementById('action-bar');
    const gameBoard = document.getElementById('game-board');
    const playerInfoDisplay = document.getElementById('player-info');
    const currentClassDetailsName = document.getElementById('info-class-name'); // Gameplay details
    const currentClassDescription = document.getElementById('info-class-description'); // Gameplay details
    const currentClassAbilitiesList = document.getElementById('info-class-abilities'); // Gameplay details
    const infoSilverBullet = document.getElementById('info-silver-bullet');
    const statusBarPlayer = document.getElementById('status-player');
    const statusBarAP = document.getElementById('status-ap');
    const statusBarTurn = document.getElementById('status-turn');
    const btnUndo = document.getElementById('btn-undo');
    const btnEndTurn = document.getElementById('btn-end-turn');
    const btnToggleLog = document.getElementById('btn-toggle-log');
    const gameLog = document.getElementById('game-log');
    const logList = document.getElementById('log-list');
    const btnBackToSetup = document.getElementById('btn-back-to-setup');
    const btnShoot = document.getElementById('action-shoot');
    const btnThrow = document.getElementById('action-throw');
    const btnSilverBullet = document.getElementById('action-silver-bullet');
    const hazardPickerPopup = document.getElementById('hazard-picker');
    const hazardPickerOptions = document.getElementById('hazard-picker-options');
    const btnCancelThrow = document.getElementById('btn-cancel-throw');


    // --- 4. Function Definitions ---

    // --- Coordinate Helper Functions ---
    function getRowColFromCoord(coord) { if (!coord || coord.length < 2) return null; const colLetter = coord.charAt(0).toUpperCase(); const rowNum = parseInt(coord.substring(1)); if (isNaN(rowNum) || colLetter < 'A' || colLetter > 'I' || rowNum < 1 || rowNum > 9) return null; return { row: rowNum, col: colLetter.charCodeAt(0) - 64 }; }
    function getCoordFromRowCol(row, col) { if (row < 1 || row > 9 || col < 1 || col > 9) return null; const colLetter = String.fromCharCode(64 + col); return `${colLetter}${row}`; }
    function getAdjacentCoord(coord, direction) { const rc = getRowColFromCoord(coord); if (!rc) return null; let { row, col } = rc; if (direction === 'N') row--; else if (direction === 'S') row++; else if (direction === 'E') col++; else if (direction === 'W') col--; return getCoordFromRowCol(row, col); }
    function getDistance(coord1, coord2) { const rc1 = getRowColFromCoord(coord1); const rc2 = getRowColFromCoord(coord2); if (!rc1 || !rc2) return Infinity; return Math.abs(rc1.row - rc2.row) + Math.abs(rc1.col - rc2.col); }

    // --- UI Helper Functions ---
    function showScreen(screenId) { Object.values(screens).forEach(screen => screen.classList.remove('active')); if (screens[screenId]) screens[screenId].classList.add('active'); else console.error(`Screen "${screenId}" not found.`); console.log(`Showing screen: ${screenId}`); }
    function displayClassDetails(className) { const data = CLASS_DATA[className]; const nameEl = document.getElementById('class-name'); const descEl = document.getElementById('class-description'); const abilitiesEl = document.getElementById('class-abilities'); const containerEl = document.getElementById('class-details-container'); if (data) { nameEl.innerHTML = `<strong>Class:</strong> ${className}`; descEl.textContent = data.description; abilitiesEl.innerHTML = ''; data.abilities.forEach(ability => { const li = document.createElement('li'); li.innerHTML = `<strong>${ability.name}:</strong> ${ability.description}`; abilitiesEl.appendChild(li); }); containerEl.style.display = 'block'; } else { nameEl.innerHTML = `<strong>Class:</strong> ---`; descEl.textContent = 'Select a class...'; abilitiesEl.innerHTML = '<li>---</li>'; } }
    function updatePlayerSetupScreen(playerIndex) { const playerNum = playerIndex + 1; currentPlayerSetupIndex = playerIndex; console.log(`Setting up for P${playerNum}`); if (!playerData[playerIndex]) playerData[playerIndex] = { name: `P${playerNum}`, class: null }; else playerData[playerIndex].class = null; playerNameInput.value = playerData[playerIndex].name !== `P${playerNum}` ? playerData[playerIndex].name : ''; playerNameInput.placeholder = `P${playerNum} Name (Optional)`; playerSetupTitle.textContent = `Player ${playerNum} Setup`; playerNameLabel.textContent = `Player ${playerNum} Name:`; let selBtn = classSelectionContainer.querySelector('.selected'); if (selBtn) selBtn.classList.remove('selected'); classButtons.forEach(button => { const cls = button.dataset.class; button.disabled = selectedClasses.includes(cls); button.style.opacity = button.disabled ? '0.5' : '1'; }); displayClassDetails(null); btnBack.style.display = (playerIndex === 0) ? 'none' : 'inline-block'; btnNext.textContent = (playerIndex === numberOfPlayers - 1) ? 'Start Game' : 'Next'; }
    function addToLog(message) { const li = document.createElement('li'); li.textContent = message; while (logList.children.length > 50) logList.removeChild(logList.firstChild); logList.appendChild(li); gameLog.scrollTop = gameLog.scrollHeight; console.log("Log:", message); }
    function generateGrid() { gameBoard.innerHTML = ''; for (let r = 1; r <= 9; r++) { for (let c = 1; c <= 9; c++) { const square = document.createElement('div'); const colLetter = String.fromCharCode(64 + c); const coord = `${colLetter}${r}`; square.classList.add('grid-square'); square.dataset.coord = coord; gameBoard.appendChild(square); } } console.log("Generated grid."); }
    function getPlayerColorClass(playerIndex) { const player = currentGameState.players[playerIndex]; return player ? (CLASS_DATA[player.class]?.color || '') : ''; }
    function renderBoard(gameState) { document.querySelectorAll('.piece').forEach(p => p.remove()); if (!gameState?.board) { console.error("Render Error: Invalid state."); return; } gameState.board.vampires?.forEach(vamp => { const targetSquare = gameBoard.querySelector(`[data-coord="${vamp.coord}"]`); if (targetSquare) { const vampElement = document.createElement('div'); const playerClass = gameState.players[vamp.player]?.class; const classColor = CLASS_DATA[playerClass]?.color || ''; vampElement.classList.add('piece', 'vampire', classColor); vampElement.dataset.id = vamp.id; vampElement.dataset.player = vamp.player; vampElement.dataset.facing = vamp.facing; if (vamp.id === gameState.selectedVampireId) vampElement.classList.add('selected'); if (vamp.cursed) vampElement.classList.add('cursed'); targetSquare.appendChild(vampElement); } }); gameState.board.bloodwells?.forEach(bw => { const targetSquare = gameBoard.querySelector(`[data-coord="${bw.coord}"]`); if (targetSquare) { const bwElement = document.createElement('div'); const playerClass = gameState.players[bw.player]?.class; const classColor = CLASS_DATA[playerClass]?.color || ''; bwElement.classList.add('piece', 'bloodwell', classColor); bwElement.dataset.id = bw.id; bwElement.dataset.player = bw.player; bwElement.textContent = '🩸'; targetSquare.appendChild(bwElement); } }); gameState.board.hazards?.forEach(hazard => { const targetSquare = gameBoard.querySelector(`[data-coord="${hazard.coord}"]`); if (targetSquare) { const hazardElement = document.createElement('div'); hazardElement.classList.add('piece', 'hazard'); const typeClass = `hazard-${hazard.type.toLowerCase().replace(' ','-')}`; hazardElement.classList.add(typeClass); let icon = '?'; if (hazard.type === 'Tombstone') icon = '🪦'; else if (hazard.type === 'Carcass') icon = '💀'; else if (hazard.type === 'Grave Dust') icon = '💩'; else if (hazard.type === 'Dynamite') icon = '💥'; hazardElement.textContent = icon; targetSquare.appendChild(hazardElement); } }); }
    function updatePlayerInfoPanel(player, turn, currentAP, resources) { if (!player || !resources) { console.error("Info Panel Error."); return; } const data = CLASS_DATA[player.class]; if (data) { currentClassDetailsName.innerHTML = `<strong>Class:</strong> ${player.class}`; currentClassDescription.textContent = data.description; currentClassAbilitiesList.innerHTML = ''; data.abilities.forEach(ability => { const li = document.createElement('li'); const isUsed = resources.abilitiesUsed.includes(ability.name); li.innerHTML = `<strong>${ability.name}:</strong> ${ability.description}`; if (isUsed) { li.style.opacity = '0.5'; li.style.textDecoration = 'line-through'; } currentClassAbilitiesList.appendChild(li); }); } infoSilverBullet.textContent = resources.silverBullet > 0 ? `Available (${resources.silverBullet})` : "Used"; statusBarPlayer.textContent = player.name; statusBarAP.textContent = currentAP; statusBarTurn.textContent = turn; const canAffordShoot = currentAP >= AP_COST.SHOOT; const canAffordThrow = currentAP >= AP_COST.THROW_HAZARD; const canAffordSilver = currentAP >= AP_COST.SILVER_BULLET && resources.silverBullet > 0; const isVampSelected = !!currentGameState.selectedVampireId; const selectedVamp = findVampireById(currentGameState.selectedVampireId); const isCursed = selectedVamp?.cursed; btnShoot.disabled = !isVampSelected || !canAffordShoot || isCursed; btnThrow.disabled = !isVampSelected || !canAffordThrow || isCursed; btnSilverBullet.disabled = !isVampSelected || !canAffordSilver || isCursed; }
    function updateUI() { if (!currentGameState?.players?.length || !currentGameState.playerResources?.length) return; const idx = currentGameState.currentPlayerIndex; if (idx < 0 || idx >= currentGameState.players.length || idx >= currentGameState.playerResources.length) { console.error("Error: Invalid currentPlayerIndex.", currentGameState); return; } const player = currentGameState.players[idx]; const resources = currentGameState.playerResources[idx]; updatePlayerInfoPanel(player, currentGameState.turn, currentGameState.currentAP, resources); }
    function clearHighlights() { document.querySelectorAll('.grid-square.valid-target, .grid-square.invalid-target').forEach(el => el.classList.remove('valid-target', 'invalid-target')); }

    // --- Game State & Undo Logic ---
    function saveStateToHistory() { try { gameHistory.push(JSON.parse(JSON.stringify(currentGameState))); btnUndo.disabled = false; console.log("State saved. History:", gameHistory.length); } catch (error) { console.error("Error saving state:", error); alert("Undo Error!"); } }
    function undoLastAction() { if (gameHistory.length > 0) { console.log("Undoing..."); try { currentGameState = gameHistory.pop(); renderBoard(currentGameState); updateUI(); addToLog("--- Action Undone ---"); btnUndo.disabled = gameHistory.length === 0; } catch (error) { console.error("Error restoring state:", error); alert("Undo Restore Error!"); } } else { console.log("Nothing to undo."); btnUndo.disabled = true; } }

    // --- Find Pieces ---
    function findVampireById(vampId) { return currentGameState.board?.vampires?.find(v => v.id === vampId); }
    function findPieceAtCoord(coord) { if (!currentGameState?.board) return null; const vamp = currentGameState.board.vampires?.find(v => v.coord === coord); if (vamp) return { type: 'vampire', piece: vamp }; const bw = currentGameState.board.bloodwells?.find(b => b.coord === coord); if (bw) return { type: 'bloodwell', piece: bw }; const hazard = currentGameState.board.hazards?.find(h => h.coord === coord); if (hazard) return { type: 'hazard', piece: hazard }; return null; }

    // --- Action Execution Functions ---
    function executeMove(vampire, targetCoord) { if (currentGameState.currentAP < AP_COST.MOVE) { addToLog("No AP."); return; } if (vampire.cursed) { addToLog("Cursed move TBD."); /* Allow for now? */ } const expectedTarget = getAdjacentCoord(vampire.coord, vampire.facing); if (targetCoord !== expectedTarget) { addToLog(`Invalid move target. Need ${expectedTarget}`); return; } const pieceAtTarget = findPieceAtCoord(targetCoord); if (pieceAtTarget && (pieceAtTarget.type === 'vampire' || pieceAtTarget.type === 'bloodwell' || pieceAtTarget.piece.type === 'Carcass')) { addToLog(`Blocked by ${pieceAtTarget.piece.type}.`); return; } saveStateToHistory(); const oldCoord = vampire.coord; vampire.coord = targetCoord; currentGameState.currentAP -= AP_COST.MOVE; addToLog(`${vampire.id} moved ${oldCoord} -> ${targetCoord}. (${currentGameState.currentAP} AP)`); if (pieceAtTarget?.type === 'hazard' && pieceAtTarget.piece.type === 'Grave Dust') if (!vampire.cursed) { vampire.cursed = true; addToLog(`${vampire.id} CURSED by Grave Dust!`); } if (vampire.cursed && pieceAtTarget?.type === 'bloodwell' && pieceAtTarget.piece.player === vampire.player && !findPieceAtCoord(targetCoord, 'hazard')) { vampire.cursed = false; addToLog(`${vampire.id} CURED by Bloodbath!`); } renderBoard(currentGameState); updateUI(); }
    function executePivot(vampire, newFacing) { if (!DIRECTIONS.includes(newFacing)) return; if (currentGameState.currentAP < AP_COST.PIVOT) { addToLog("No AP."); return; } saveStateToHistory(); vampire.facing = newFacing; currentGameState.currentAP -= AP_COST.PIVOT; addToLog(`${vampire.id} pivoted ${newFacing}. (${currentGameState.currentAP} AP)`); renderBoard(currentGameState); updateUI(); }
    function executeShoot(vampire, isSilverBullet = false) { const cost = isSilverBullet ? AP_COST.SILVER_BULLET : AP_COST.SHOOT; if (currentGameState.currentAP < cost) { addToLog(`No AP.`); return; } if (vampire.cursed) { addToLog("Cursed cannot shoot."); return; } const res = currentGameState.playerResources[vampire.player]; if (isSilverBullet && res.silverBullet <= 0) { addToLog("No Silver Bullet."); return; } saveStateToHistory(); const shooterIdx = vampire.player; const shooterCls = currentGameState.players[shooterIdx].class; let currCoord = vampire.coord; let msg = `Shot off board.`; addToLog(`${vampire.id} ${isSilverBullet ? 'fires SB' : 'shoots'} ${vampire.facing}...`); if (isSilverBullet) res.silverBullet--; currentGameState.currentAP -= cost; for (let i = 0; i < 9; i++) { currCoord = getAdjacentCoord(currCoord, vampire.facing); if (!currCoord) break; const target = findPieceAtCoord(currCoord); if (target) { const tType = target.type; const tPiece = target.piece; if (tType === 'hazard' && (tPiece.type === 'Tombstone' || tPiece.type === 'Dynamite')) { if (tPiece.type === 'Tombstone' && shooterCls === 'Bounty Hunter') { addToLog(`Passes Tombstone.`); continue; } msg = `Blocked by ${tPiece.type}.`; if (tPiece.type === 'Dynamite') { msg += ` EXPLODES!`; const idx = currentGameState.board.hazards.findIndex(h => h.coord === currCoord); if (idx > -1) currentGameState.board.hazards.splice(idx, 1); /* TODO: Explosion area effect */ addToLog("Dynamite logic TBD."); } break; } if (tType === 'vampire') { if (isSilverBullet && tPiece.player !== shooterIdx) { msg = `SB HIT & ELIMINATED ${tPiece.id}!`; currentGameState.board.vampires = currentGameState.board.vampires.filter(v => v.id !== tPiece.id); /* TODO: Check player elim */ } else if (shooterCls === 'Bounty Hunter' && tPiece.player !== shooterIdx && !tPiece.cursed) { msg = `HIT ${tPiece.id}. CURSED!`; const targetV = findVampireById(tPiece.id); if (targetV) targetV.cursed = true; } else { msg = `Hit ${tPiece.id}.`; } break; } if (tType === 'bloodwell') { /* TODO: Check Sheriff protection */ msg = `DESTROYED BW ${tPiece.id}!`; currentGameState.board.bloodwells = currentGameState.board.bloodwells.filter(bw => bw.id !== tPiece.id); /* TODO: Check player elim */ break; } if (tType === 'hazard' && (tPiece.type === 'Carcass' || tPiece.type === 'Grave Dust')) { addToLog(`Passes ${tPiece.type}.`); continue; } } } addToLog(msg + ` (${currentGameState.currentAP} AP)`); renderBoard(currentGameState); updateUI(); /* TODO: Check win/loss */ }
    function executeThrow(vampire, hazardType, targetCoord) { const cost = hazardType === 'Dynamite' ? AP_COST.THROW_DYNAMITE : AP_COST.THROW_HAZARD; if (currentGameState.currentAP < cost) { addToLog(`No AP.`); return; } if (vampire.cursed) { addToLog("Cursed cannot throw."); return; } if (currentGameState.hazardPool[hazardType] <= 0) { addToLog(`No ${hazardType}.`); return; } const dist = getDistance(vampire.coord, targetCoord); if (dist === 0 || dist > 3) { addToLog(`Bad distance.`); return; } const targetPiece = findPieceAtCoord(targetCoord); if (targetPiece && !(hazardType === 'Grave Dust' && targetPiece.type === 'vampire')) { addToLog(`Target blocked.`); return; } /* TODO: Path validation */ saveStateToHistory(); currentGameState.hazardPool[hazardType]--; currentGameState.board.hazards.push({ type: hazardType, coord: targetCoord }); currentGameState.currentAP -= cost; addToLog(`${vampire.id} threw ${hazardType} to ${targetCoord}. (${currentGameState.currentAP} AP)`); if (hazardType === 'Grave Dust' && targetPiece?.type === 'vampire') { const targetV = findVampireById(targetPiece.piece.id); if (targetV && !targetV.cursed) { targetV.cursed = true; addToLog(`${targetV.id} CURSED by GD!`); } } renderBoard(currentGameState); updateUI(); }
    function nextTurn() { saveStateToHistory(); const prevIdx = currentGameState.currentPlayerIndex; /* TODO: End-of-turn effects */ let nextIdx = (prevIdx + 1) % numberOfPlayers; let check = 0; while (currentGameState.players[nextIdx]?.eliminated && check < numberOfPlayers) { nextIdx = (nextIdx + 1) % numberOfPlayers; check++; } if (check >= numberOfPlayers && !currentGameState.players[nextIdx]?.eliminated) { console.error("Turn advance failed!"); addToLog("Turn Error!"); undoLastAction(); return; } currentGameState.currentPlayerIndex = nextIdx; if (nextIdx <= prevIdx) currentGameState.turn++; const playerIdx = currentGameState.currentPlayerIndex; if (currentGameState.turn === 1) { if (numberOfPlayers === 4) currentGameState.currentAP = [4, 5, 6, 8][playerIdx]; else if (numberOfPlayers === 3) currentGameState.currentAP = 6; else if (numberOfPlayers === 2) currentGameState.currentAP = 5; } else { currentGameState.currentAP = 5; } /* TODO: Blood Brothers check */ currentGameState.selectedVampireId = null; currentGameState.actionState = { pendingAction: null, selectedHazardType: null }; btnUndo.disabled = true; /* gameHistory = []; // Optionally clear history */ renderBoard(currentGameState); updateUI(); const currPlayer = currentGameState.players[currentGameState.currentPlayerIndex]; addToLog(`--- Turn ${currentGameState.turn} - ${currPlayer.name}'s turn (${currPlayer.class}). AP: ${currentGameState.currentAP} ---`); /* TODO: Check Victory */ }

    // --- Event Listener Handlers ---
    function handleBoardClick(event) { const squareEl = event.target.closest('.grid-square'); if (!squareEl) return; const coord = squareEl.dataset.coord; const pending = currentGameState.actionState.pendingAction; if (pending === 'throw-select-target') { const type = currentGameState.actionState.selectedHazardType; const vamp = findVampireById(currentGameState.selectedVampireId); executeThrow(vamp, type, coord); currentGameState.actionState = { pendingAction: null, selectedHazardType: null }; clearHighlights(); } else if (pending === 'move-select-target') { const vamp = findVampireById(currentGameState.selectedVampireId); if (vamp) executeMove(vamp, coord); currentGameState.actionState = { pendingAction: null }; clearHighlights(); } else { handleVampireSelection(event); } }
    function handleVampireSelection(event) { const vampEl = event.target.closest('.vampire'); if (vampEl) { const vampId = vampEl.dataset.id; const ownerIdx = parseInt(vampEl.dataset.player); if (ownerIdx === currentGameState.currentPlayerIndex) { if (currentGameState.selectedVampireId !== vampId) { currentGameState.selectedVampireId = vampId; renderBoard(currentGameState); updateUI(); console.log(`Selected ${vampId}`); } } else { addToLog("Cannot select opponent."); if (currentGameState.selectedVampireId) { currentGameState.selectedVampireId = null; renderBoard(currentGameState); updateUI(); } } } else if (event.target.classList.contains('grid-square')) { if (currentGameState.selectedVampireId && !currentGameState.actionState.pendingAction) { currentGameState.selectedVampireId = null; renderBoard(currentGameState); updateUI(); clearHighlights(); console.log("Deselected."); } } }
    function clearHighlights() { document.querySelectorAll('.grid-square.valid-target, .grid-square.invalid-target').forEach(el => el.classList.remove('valid-target', 'invalid-target')); }

    // --- Functions for Throw Action ---
    function populateHazardPicker() { hazardPickerOptions.innerHTML = ''; if (!currentGameState?.hazardPool || typeof currentGameState.currentAP === 'undefined') { console.error("Cannot populate picker: Invalid state."); addToLog("Error prepping throw."); return; } const pool = currentGameState.hazardPool; const ap = currentGameState.currentAP; const createBtn = (type, icon, cost) => { const btn = document.createElement('button'); btn.dataset.hazardType = type; const count = pool[type] || 0; btn.innerHTML = `<span class="hazard-icon">${icon}</span> ${type} <span class="hazard-cost">(${cost} AP)</span>`; btn.disabled = count <= 0 || ap < cost; btn.title = `${count} available`; hazardPickerOptions.appendChild(btn); }; createBtn('Tombstone', '🪦', AP_COST.THROW_HAZARD); createBtn('Carcass', '💀', AP_COST.THROW_HAZARD); createBtn('Grave Dust', '💩', AP_COST.THROW_HAZARD); createBtn('Dynamite', '💥', AP_COST.THROW_DYNAMITE); }
    function handleHazardSelection(hazardType) { console.log("Selected hazard:", hazardType); const cost = hazardType === 'Dynamite' ? AP_COST.THROW_DYNAMITE : AP_COST.THROW_HAZARD; if (!currentGameState?.hazardPool || !currentGameState.actionState) { console.error("Cannot handle selection: Invalid state."); return; } if (currentGameState.hazardPool[hazardType] <= 0) { addToLog(`No ${hazardType}.`); return; } if (currentGameState.currentAP < cost) { addToLog(`Not enough AP.`); return; } currentGameState.actionState.pendingAction = 'throw-select-target'; currentGameState.actionState.selectedHazardType = hazardType; hazardPickerPopup.style.display = 'none'; highlightThrowTargets(); addToLog(`Throwing ${hazardType}. Select target.`); }
    function highlightThrowTargets() { clearHighlights(); const vamp = findVampireById(currentGameState.selectedVampireId); if (!vamp || !currentGameState?.actionState) return; const startCoord = vamp.coord; const type = currentGameState.actionState.selectedHazardType; if (!type) return; document.querySelectorAll('.grid-square').forEach(sq => { const targetCoord = sq.dataset.coord; const dist = getDistance(startCoord, targetCoord); let isValid = false; if (dist > 0 && dist <= 3) { const targetPiece = findPieceAtCoord(targetCoord); if (!targetPiece || (type === 'Grave Dust' && targetPiece.type === 'vampire')) { /* TODO: Path validation */ isValid = true; } } if (isValid) sq.classList.add('valid-target'); /* else sq.classList.add('invalid-target'); */ }); }

    // --- Initialization ---
    function initializeGame() { console.log("Initializing game..."); gameHistory = []; const layouts = LAYOUT_DATA[numberOfPlayers]; if (!layouts?.length) { alert(`Error: No layouts for ${numberOfPlayers}P!`); showScreen('playerCount'); return; } const layoutIdx = Math.floor(Math.random() * layouts.length); const layout = layouts[layoutIdx]; addToLog(`Selected Layout: ${numberOfPlayers}P #${layoutIdx + 1}`); currentGameState = { players: playerData.map(p => ({ name: p.name, class: p.class, eliminated: false })), board: { vampires: JSON.parse(JSON.stringify(layout.vampires.map(v => ({...v, cursed: false})))), bloodwells: JSON.parse(JSON.stringify(layout.bloodwells)), hazards: JSON.parse(JSON.stringify(layout.hazards)) }, hazardPool: { 'Tombstone': 4 - layout.hazards.filter(h => h.type === 'Tombstone').length, 'Carcass': 4 - layout.hazards.filter(h => h.type === 'Carcass').length, 'Grave Dust': 4 - layout.hazards.filter(h => h.type === 'Grave Dust').length, 'Dynamite': 3 }, playerResources: playerData.map(() => ({ silverBullet: 1, abilitiesUsed: [] })), turn: 1, currentPlayerIndex: 0, currentAP: 0, selectedVampireId: null, actionState: { pendingAction: null, selectedHazardType: null } }; const pIdx = currentGameState.currentPlayerIndex; if (currentGameState.turn === 1) { if (numberOfPlayers === 4) currentGameState.currentAP = [4, 5, 6, 8][pIdx]; else if (numberOfPlayers === 3) currentGameState.currentAP = 6; else if (numberOfPlayers === 2) currentGameState.currentAP = 5; } else currentGameState.currentAP = 5; generateGrid(); renderBoard(currentGameState); const player = currentGameState.players[pIdx]; if (!player) { console.error("Init fail: No player."); return; } const resources = currentGameState.playerResources[pIdx]; updatePlayerInfoPanel(player, currentGameState.turn, currentGameState.currentAP, resources); logList.innerHTML = `<li>Game Started: ${numberOfPlayers}P Layout #${layoutIdx + 1}</li>`; gameLog.scrollTop = 0; btnUndo.disabled = true; gameBoard.removeEventListener('click', handleBoardClick); gameBoard.addEventListener('click', handleBoardClick); btnUndo.removeEventListener('click', undoLastAction); btnUndo.addEventListener('click', undoLastAction); btnEndTurn.removeEventListener('click', nextTurn); btnEndTurn.addEventListener('click', nextTurn); showScreen('gameplay'); addToLog(`Turn ${currentGameState.turn} - ${player.name}'s turn (${player.class}). AP: ${currentGameState.currentAP}`); }

    // --- Attach Event Listeners ---
    // Setup Screens Listeners
    playerCountButtons.forEach(button => { button.addEventListener('click', () => { numberOfPlayers = parseInt(button.dataset.count); playerData = new Array(numberOfPlayers); selectedClasses = []; updatePlayerSetupScreen(0); showScreen('playerSetup'); }); });
    classButtons.forEach(button => { button.addEventListener('click', () => { if (button.disabled) return; let sel = classSelectionContainer.querySelector('.selected'); if (sel) sel.classList.remove('selected'); button.classList.add('selected'); const cls = button.dataset.class; if (playerData[currentPlayerSetupIndex]) playerData[currentPlayerSetupIndex].class = cls; displayClassDetails(cls); }); });
    playerNameInput.addEventListener('input', () => { if(playerData[currentPlayerSetupIndex]) playerData[currentPlayerSetupIndex].name = playerNameInput.value.trim() || `P${currentPlayerSetupIndex + 1}`; });
    btnBack.addEventListener('click', () => { const cls = playerData[currentPlayerSetupIndex]?.class; if(cls) { const idx = selectedClasses.indexOf(cls); if (idx > -1) selectedClasses.splice(idx, 1); } if (currentPlayerSetupIndex > 0) updatePlayerSetupScreen(currentPlayerSetupIndex - 1); else { selectedClasses = []; playerData = []; showScreen('playerCount'); } });
    btnNext.addEventListener('click', () => { const data = playerData[currentPlayerSetupIndex]; if (!data || !data.class) { alert(`Please select a class for Player ${currentPlayerSetupIndex + 1}!`); return; } if (!data.name) data.name = `P${currentPlayerSetupIndex + 1}`; if (!selectedClasses.includes(data.class)) selectedClasses.push(data.class); if (currentPlayerSetupIndex < numberOfPlayers - 1) updatePlayerSetupScreen(currentPlayerSetupIndex + 1); else initializeGame(); });
    // Gameplay Screen Listeners
    btnToggleLog.addEventListener('click', () => { gameLog.classList.toggle('log-hidden'); });
    btnBackToSetup.addEventListener('click', () => { if (confirm("Return to setup? Game progress will be lost.")) { numberOfPlayers = 0; currentPlayerSetupIndex = 0; playerData = []; selectedClasses = []; currentGameState = {}; gameHistory = []; showScreen('playerCount'); } });
    // Action Buttons
    btnShoot.addEventListener('click', () => { const vamp = findVampireById(currentGameState.selectedVampireId); if (vamp) executeShoot(vamp, false); else addToLog("Select Vampire."); });
    btnSilverBullet.addEventListener('click', () => { const vamp = findVampireById(currentGameState.selectedVampireId); const res = currentGameState.playerResources[currentGameState.currentPlayerIndex]; if (vamp && res.silverBullet > 0) { if (confirm("Use Silver Bullet?")) executeShoot(vamp, true); } else if (!vamp) addToLog("Select Vampire."); else addToLog("No Silver Bullet."); });
    btnThrow.addEventListener('click', () => { const vamp = findVampireById(currentGameState.selectedVampireId); if (!vamp) { addToLog("Select Vampire."); return; } if (vamp.cursed) { addToLog("Cursed cannot throw."); return; } if (currentGameState.currentAP < AP_COST.THROW_HAZARD) { addToLog("Not enough AP."); return; } populateHazardPicker(); hazardPickerPopup.style.display = 'flex'; currentGameState.actionState.pendingAction = 'throw-select-hazard'; addToLog("Select hazard to throw."); });
    btnCancelThrow.addEventListener('click', () => { hazardPickerPopup.style.display = 'none'; currentGameState.actionState = { pendingAction: null, selectedHazardType: null }; clearHighlights(); addToLog("Throw cancelled."); });
    hazardPickerOptions.addEventListener('click', (event) => { const btn = event.target.closest('button'); if (btn?.dataset.hazardType) handleHazardSelection(btn.dataset.hazardType); });

    // --- Initial Load ---
    showScreen('playerCount'); // Start with the player count screen

}); // End DOMContentLoaded
